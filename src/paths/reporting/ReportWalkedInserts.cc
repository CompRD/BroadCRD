///////////////////////////////////////////////////////////////////////////////
//                   SOFTWARE COPYRIGHT NOTICE AGREEMENT                     //
//       This software and its documentation are copyright (2010) by the     //
//   Broad Institute.  All rights are reserved.  This software is supplied   //
//   without any warranty or guaranteed support whatsoever. The Broad        //
//   Institute is not responsible for its use, misuse, or functionality.     //
///////////////////////////////////////////////////////////////////////////////

#include "CoreTools.h"
#include "MainTools.h"
#include "Basevector.h"
#include "TokenizeString.h"
#include "VecUtilities.h"
#include "lookup/LookAlign.h"
#include "lookup/QueryLookupTableCore.h"
#include "paths/reporting/ReftigUtils.h"
#include "util/RunCommand.h"
#include "feudal/BinaryStream.h"

/**
 * Forward declarations
 */
void PlacePairsOnTarget( ostream &out,
			 const int &nhood_id,
			 const String &range,
			 const vec<String> &names,
			 const vec<look_align> &aligns );

/**
 * ReportWalkedInserts
 *
 * It reports various metrics on the inserts selected for walking in
 * LocalizeReadsLG.
 * 
 * REQUIRED INPUT
 *
 *  1. The files *.selected_pairs.fasta in seed/N/ (these can be
 *     generated by running LocalizeReadsLG with the extra options
 *     LOCAL_DUMP=SELECTED_PAIRS,UNIBASES).
 * 
 *  2. The output from MapNhoodsToAssemblyRegion (it looks for files
 *     in ../<ASSEMBLY_HEAD>.<MAPS_EXT>/N/)
 *
 * NHOOD_IDS: selected nhoods
 * ASSEMBLY_DIR: full path name to where the assembly data are stored
 * ASSEMBLY_HEAD: head of assembly name
 * MAPS_EXT: where map files are located 
 * REFTIGS_ONLY: just show the reftigs
 * ARCHIVE: send output to file, rather than cout
 * FORCE: do not use cached data
 */
int main( int argc, char *argv[] )
{
  RunTime();
  
  BeginCommandArguments;
  CommandArgument_String( NHOOD_IDS );
  CommandArgument_String( ASSEMBLY_DIR );
  CommandArgument_String_OrDefault( ASSEMBLY_HEAD, "final"  );
  CommandArgument_String_OrDefault( MAPS_EXT, "nhoods.map"  );
  CommandArgument_Bool_OrDefault( REFTIGS_ONLY, False );
  CommandArgument_Bool_OrDefault( ARCHIVE, True );
  CommandArgument_Bool_OrDefault( FORCE, False );
  EndCommandArguments;

  // Constants.
  const int K = 96;   // Used by various functions in ReftigUtils.

  // Dir and file names.
  String full_assembly_head = ASSEMBLY_DIR + "/" + ASSEMBLY_HEAD;
  String seed_dir = ASSEMBLY_DIR + "/seed";
  String maps_dir = full_assembly_head + "." + MAPS_EXT;
  
  // Selected nhoods.
  vec<int> nhood_ids;
  ParseIntSet( NHOOD_IDS, nhood_ids );

  // Loop over all selected nhood_ids.
  for (int select=0; select<nhood_ids.isize( ); select++) {
    int nhood_id = nhood_ids[select];
    String str_nhood = ToString( nhood_id );
    String base_dir = ToString( nhood_id / 1000 );
    String seed_head = seed_dir + "/" + base_dir + "/" + str_nhood;
    String map_head = maps_dir + "/" + base_dir + "/" + str_nhood;
    String tmp_dir = maps_dir + "/" + base_dir;
    
    String pairs_fasta_file = seed_head + ".selected_pairs.fasta";
    String unibases_fasta_file = seed_head + ".local_unibases.fasta";
    String unibases_fastb_file = seed_head + ".local_unibases.fastb";
    String unibases_hbv_file = seed_head + ".local_unibases.hbv";
    String log_file = map_head + ".ReportWalkedInserts.log";
    String chunk_lookup_file = map_head + ".chunk.lookup";
    String chunk_range_file = map_head + ".chunk.range";
    String selected_pairs_aligns_file = map_head + ".selected_pairs.qlt";
    String local_unibases_aligns_file = map_head + ".local_unibases.qlt";

    // Log stream
    ofstream archive_out;
    if ( ARCHIVE ) {
      cout << "nhood_" << nhood_id << ":\tsee " << log_file.c_str( ) << endl;
      archive_out.open( log_file.c_str( ) );
    }
    ostream &out = ARCHIVE ? archive_out : * (ostream *) &cout;
    
    // Range for this nhood.
    String range = FirstLineOfFile( chunk_range_file );
    
    // Generate reftigs of local unibases.
    HyperBasevector local_hbv;
    BinaryReader::readFile( unibases_hbv_file, &local_hbv );
    
    if ( FORCE || ! IsRegularFile( unibases_fastb_file ) ) {
      local_hbv.DumpFasta( unibases_fasta_file );
      local_hbv.DumpFastb( unibases_fastb_file );
    }

    vec<look_align> unibases_aligns;
    GetAlignsFast( K, unibases_fastb_file, chunk_lookup_file,
		   local_unibases_aligns_file, unibases_aligns,
		   ! FORCE, tmp_dir );
    
    vec< pair<int,ho_interval> > reftigs;
    HyperToReftigsCore( K, local_hbv, unibases_aligns, reftigs );

    int min_len = 250;
    int offset = range.After( ":" ).Before( "-" ).Int( );
    out << "Reftigs longer than " << min_len
	<< " bases, built from the local unibases of nhood " << nhood_id
	<< ":\n" << endl;
    if ( reftigs.size( ) > 0 )
      PrintReftigs( out, K, offset, reftigs, 0, min_len );
    else
      out << "none found\n" << endl;
    
    if ( REFTIGS_ONLY ) continue;
    
    // Generate aligns of selected pairs.
    if ( FORCE || ! IsRegularFile( selected_pairs_aligns_file ) ) {
      vec<String> needed;
      needed = MkVec( pairs_fasta_file, chunk_lookup_file, chunk_range_file );
      if ( ! CheckFilesExist( needed, &out ) ) continue;
      
      out << Date( ) << ": aligning pairs of nhood_" << nhood_id << endl;
      String qlt_args = 
	String ( "K=12 MM=48 MF=500 SH=True MC=0.15 " )
	+ String( " AI=True PARSEABLE=True PRINT_MEMORY_USAGE=True" )
	+ String( " LIST_UNPLACED_BY_PASS=False" )
	+ String( " TMP_DIR=" ) + tmp_dir
	+ String( " SEQS=" ) + pairs_fasta_file
	+ String( " L=" ) + chunk_lookup_file
	+ String( " OUTPUT=" ) + selected_pairs_aligns_file;
      
      QueryLookupTableCore( qlt_args );
    }

    // Load local nhood data.
    vec<look_align> aligns;
    LoadLookAligns( selected_pairs_aligns_file, aligns );
    sort( aligns.begin( ), aligns.end( ) );

    vec<String> names;
    vec<fastavector> fasta;
    LoadFromFastaFile( pairs_fasta_file, fasta, names );

    // Place pairs on target.
    PlacePairsOnTarget( out, nhood_id, range, names, aligns );
    
  }

  // Done.
  if ( ARCHIVE ) cout << "\n";
  cout << Date( ) << ": done" << endl;
  
}



/**
 * CNameInfo
 *
 * Class to parse a read name (very specific to the format used by
 * LocalizeReadsLG when run with LOCAL_DUMP=SELECTED_PAIRS).
 */
class CNameInfo {

public:

  CNameInfo( ) : 
    local_id_ ( -1 ),
    global_id_ ( -1 ),
    sep_ ( -1 ),
    dev_ ( -1 ),
    redundant_ ( false ),
    walked_ ( false )
  { }

  CNameInfo( const String &name ) { this->ParseName( name ); }
  
  void ParseName( const String &name ) {
    vec<String> tokens;
    Tokenize( name, tokens );
    local_id_ = tokens[1].After( "=" ).Int( );
    global_id_ = tokens[2].After( "=" ).Int( );
    sep_ = tokens[3].After( "=" ).Int( );
    dev_ = tokens[4].After( "=" ).Int( );
    redundant_ = ( tokens.size( ) > 6 && tokens[6] == "redundant" );
    walked_ = ( "yes" == tokens[5].After( "=" ) );
  }

  longlong    LocalId( ) const { return local_id_; }
  longlong   GlobalId( ) const { return global_id_; }
  int             Sep( ) const { return sep_; }
  int             Dev( ) const { return dev_; }
  bool      Redundant( ) const { return redundant_; }
  bool         Walked( ) const { return walked_; }
  String StrRedundant( ) const { return( redundant_ ? "yes" : "no" ); }
  String    StrWalked( ) const { return( walked_ ? "yes" : "no" ); }
  
  double Stretch( int observed_sep ) const {
    ForceAssert( dev_ > 0 );
    return ( double( observed_sep - sep_ ) / double( dev_ ) );
  }

  String LibSepDev( ) const {
    return "<" + ToString( sep_ ) + " +/- " + ToString( dev_ ) + ">";
  }
  
  String StrGlobalIds( ) const {
    int head2 = 1 + ( global_id_ - 10 * ( global_id_ / 10 ) );
    return ToString( global_id_ ) + "/" + ToString( head2 );
  }
  
  
private:
  
  longlong local_id_;
  longlong global_id_;
  int sep_;
  int dev_;
  bool redundant_;
  bool walked_;
  
};



/**
 * PlacePairsOnTarget
 *
 * range: used to compute aligns' offsets
 * names: contain informations about the pair (eg: sep and dev
 */
void PlacePairsOnTarget( ostream &out,
			 const int &nhood_id,
			 const String &range,			 
			 const vec<String> &names,
			 const vec<look_align> &aligns )
{
  // Description.
  out << "Placements for nhood_" << nhood_id
      << ", sorted by start on range. RANGE = " << range
      << "\n" << endl;

  // Forget about multiply placed reads.
  vec<int> to_align( names.size( ), -1 );
  for (int ii=0; ii<aligns.isize( ); ii++) {
    int read_id = aligns[ii].query_id;
    if ( to_align[read_id] == -1 ) to_align[read_id] = ii;
    else to_align[read_id] = -2;
  }

  // Used to sort table below.
  int range_begin = range.After( ":" ).Before( "-" ).Int( );
  int sort_label = range_begin - 10;
  int sort_unmapped = range_begin - 3;
  int sort_same_orientation = range_begin - 2;
  int sort_non_jump = range_begin - 1;
  vec< triple<int,int,int> > sorter;

  // Printable table.
  vec< vec<String> > table;
  vec<String> line = MkVec( ToString( "pair" ),
			    ToString( "read ids" ),
			    ToString( "library" ),
			    ToString( "redundant" ),
			    ToString( "walked" ),
			    ToString( "begin" ),
			    ToString( "end" ),
			    ToString( "sep" ),
			    ToString( "stretch" ) );
  table.push_back( line );
  sorter.push_back( triple<int,int,int>( sort_label, 0, 0 ) );

  // Loop over all pairs.
  int n_pairs = names.isize( ) / 2;
  int super_id = range.Before( ":" ).Int( );
  int offset = range.After( ":" ).Before( "-" ).Int( );
  for (int pair_id=0; pair_id<n_pairs; pair_id++) {
    int id1 = 2 * pair_id;
    int id2 = id1 + 1;
    CNameInfo info( names[id1] );

    line = MkVec( ToString( pair_id ),
		  info.StrGlobalIds( ),
		  info.LibSepDev( ),
		  info.StrRedundant( ),
		  info.StrWalked( ),
		  ToString( "na" ),
		  ToString( "na" ),
		  ToString( "na" ),
		  ToString( "na" ) );
    
    if ( to_align[id1] < 0 || to_align[id2] < 0 ) {
      line[5] = "unmapped";
      table.push_back( line );
      sorter.push_back( triple<int,int,int>( sort_unmapped, 0, 0 ) );
      continue;
    }
    const look_align_plus &al1 = aligns[ to_align[id1] ];
    const look_align_plus &al2 = aligns[ to_align[id2] ];
    if ( al1.Fw1( ) == al2.Fw1( ) ) {
      line[5] = "same_orientation";
      table.push_back( line );
      sorter.push_back( triple<int,int,int>( sort_same_orientation, 0, 0 ) );
      continue;
    }
    const look_align_plus &alFw = al1.Fw1( ) ? al1 : al2;
    const look_align_plus &alRc = al1.Fw1( ) ? al2 : al1;
    if ( alRc.StartOnTarget( ) <= alFw.StartOnTarget( ) ) {
      line[5] = "non-jump";
      table.push_back( line );
      sorter.push_back( triple<int,int,int>( sort_non_jump, 0, 0 ) );
      continue;
    }
    int begin = offset + alFw.StartOnTarget( );
    int end = offset + alRc.EndOnTarget( );
    int observed_sep = alRc.StartOnTarget( ) - alFw.EndOnTarget( );
    double stretch = info.Stretch( observed_sep );
    line[5] = ToString( begin );
    line[6] = ToString( end );
    line[7] = ToString( observed_sep );
    line[8] = ToString( stretch, 1 );
    table.push_back( line );
    sorter.push_back( triple<int,int,int>( begin, end, info.GlobalId( ) ) );
  }
  
  // Sort table by start on range.
  SortSync( sorter, table );

  // Print table.
  PrintTabular( out, table, 3, "rrrrrrrrr" );
  out << endl;
  
}

