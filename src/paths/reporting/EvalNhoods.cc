///////////////////////////////////////////////////////////////////////////////
//                   SOFTWARE COPYRIGHT NOTICE AGREEMENT                     //
//       This software and its documentation are copyright (2009) by the     //
//   Broad Institute.  All rights are reserved.  This software is supplied   //
//   without any warranty or guaranteed support whatsoever. The Broad        //
//   Institute is not responsible for its use, misuse, or functionality.     //
///////////////////////////////////////////////////////////////////////////////

#include "CoreTools.h"
#include "MainTools.h"
#include "Basevector.h"
#include "SeqInterval.h"
#include "math/NStatsTools.h"
#include "paths/reporting/CNhoodEval.h"

/**
 * EvalNhoods
 *
 * Eval local assemblies by parsing all the log files. It requires the
 * file seeds.map (generated by running MapSeeds).
 */
int main( int argc, char *argv[] )
{
  RunTime( );
  
  BeginCommandArguments;
  CommandArgument_String( PRE );
  CommandArgument_String( DATA );
  CommandArgument_String( RUN );
  CommandArgument_String_OrDefault( SUBDIR, "test" );
  CommandArgument_Bool_OrDefault( VERBOSE, False );
  EndCommandArguments;
  
  // Dir and file names.
  String run_dir = PRE + "/" + DATA + "/" + RUN;
  String sub_dir = run_dir + "/ASSEMBLIES/" + SUBDIR;
  String seeds_dir = sub_dir + "/seed";
  
  String seeds_ids_file = sub_dir + "/seeds.ids";
  String seeds_map_file = sub_dir + "/seeds.map";

  // Early exit if seeds.map is not found.
  if ( ! IsRegularFile( seeds_map_file ) ) {
    cout << "Fatal error: seeds.map file not found (try running MapSeeds)\n"
	 << endl;
    return 0;
  }

  // Load seeds info.
  cout << Date( ) << ": loading seed ids" << endl;
  vec<int> seed;    // sorted ids of seeds
  vec<int> nhood;   // nhoods[ii] = id of nhood for seed[ii]
  {
    READX( seeds_ids_file, seed );
    nhood.reserve( seed.size( ) );
    for (int ii=0; ii<seed.isize( ); ii++)
      nhood.push_back( ii );
    SortSync( seed, nhood );
  }
  if ( nhood.size( ) < 1 ) {
    cout << "No local assemblies found." << endl;
    return 0;
  }
  
  // Report core info.
  vec<int> nhood_lens;    // extents of local nhoods
  vec<int> seed_lens;     // lenghts of seeds
  vec<int> missing_log;   // ids of nhoods for which no log was found
  vec<seq_interval> wins; // windows on reference (may be empty)

  nhood_lens.reserve( nhood.size( ) );
  seed_lens.reserve( nhood.size( ) );
  wins.reserve( nhood.size( ) );

  // Eval local assemblies.
  int dotter = 100;
  cout << Date( ) << ": parsing "
       << nhood.size( ) << " log files (.="
       << dotter << " files):"
       << endl;

  bool true_locs = false;
  for (int ii=0; ii<nhood.isize( ); ii++) {
    if ( ii % dotter == 0 ) Dot( cout, ii / dotter );
    
    String log_file = seeds_dir + "/" + GetDirFromKey( ii, 1000 )
      + "/" + ToString( ii ) + ".log";
    if ( ! IsRegularFile( log_file ) )
      log_file = seeds_dir + "/" + GetNestedDirsFromKey( ii ) + "/log";
    if ( ! IsRegularFile( log_file ) ) {
      missing_log.push_back( ii );
      continue;
    }
    
    CNhoodEval neval( log_file );
    if ( ii == 0 ) true_locs = neval.TrueLocsExist( );
    pair<int,int> win = true_locs ? neval.TrueWin( ) : neval.CloudWin( );
    nhood_lens.push_back( win.second - win.first );
    seed_lens.push_back( neval.CloudLength( neval.SeedId( ) ) );

    if ( true_locs ) {
      int seq_id = neval.TrueTargetId( 0 );
      int interval_id = ii;
      int begin = win.first;
      int end = win.second;
      
      wins.push_back( seq_interval( interval_id, seq_id, begin, end ) );
    }
    
  }
  cout << "\n" << endl;

  ////
  // Extra output if eval code was run upstream of EvalNhoods. At this
  //  time (2010/05/12) this is not working properly, since it does
  //  not deal with local nhoods that "wrap around" circular genomes
  //  (eg ecoli), and of outlier alignments.
  // 
  //  WARNING: UPGRADE THIS COMMENT IF YOU CHANGE THE CODE!
  //
  if ( VERBOSE && wins.size( ) > 0 ) {
    sort( wins.begin( ), wins.end( ) );
    
    int last_id = wins[0].SeqId( );
    int last_end = wins[0].End( );
    cout << wins[0] << "\n";
    for (int ii=1; ii<wins.isize( ); ii++) {
      if ( wins[ii].SeqId( ) != last_id ) {
	cout << "  break - next target\n"
	     << wins[ii] << "\n";
	last_id = wins[ii].SeqId( );
	last_end = wins[ii].End( );
	continue;
      }
      if ( wins[ii].Begin( ) > last_end ) {
	int gap = wins[ii].Begin( ) - last_end;
	cout << "  gap of " << gap
	     << " bp: [" << last_end
	     << ", " << wins[ii].Begin( )
	     << ")\n";
	last_end = wins[ii].End( );
	continue;
      }
      cout << wins[ii] << "\n";
      last_end = Max( last_end, wins[ii].End( ) );
    }
    cout << endl;
  }
  
  // Print results.
  if ( missing_log.size( ) > 1 ) {
    int n_miss = missing_log.size( );
    int n_nhoods = nhood.size( );
    double ratio = SafeQuotient( n_miss, n_nhoods );
    String str_ratio = ToString( 100.0 * ratio, 2 );
    cout << "WARNING: " << n_miss
	 << " nhoods (corresponding to " << str_ratio
	 << "% of the total) did not own a proper log file.\n" << endl;
  }

  cout << "SEED LENGTHS STATISTICS" << endl;
  PrintBasicNStats( "seed_len", seed_lens, cout );

  cout << "\nNHOODS EXTENT STATISTICS" << endl;
  PrintBasicNStats( "nhood_len", nhood_lens, cout );
    
  // Done.
  cout << "\n" << Date( ) << ": done" << endl;
  
}
