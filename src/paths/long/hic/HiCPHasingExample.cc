///////////////////////////////////////////////////////////////////////////////
//                   SOFTWARE COPYRIGHT NOTICE AGREEMENT                     //
//       This software and its documentation are copyright (2013) by the     //
//   Broad Institute.  All rights are reserved.  This software is supplied   //
//   without any warranty or guaranteed support whatsoever. The Broad        //
//   Institute is not responsible for its use, misuse, or functionality.     //
///////////////////////////////////////////////////////////////////////////////

// HiCPhasingExample.  This example illustrates phasing for a 20 kb region in NA12878
// whose assembly consists of 14 bubbles.
//
// The assembly was generated by:
// r47304:LongProto SAMPLE=human READS=#picard TMP=tmp.xxx OUT_INT_HEAD=aaa 
//      X=14:21.035M-21.055M
//
// The bubbles in the assembly were manually read off the assembly dot file and
// transcribed into b (below).
//
// HiC reads for the region were provided by Maxim in a file reads.txt.  Column 11
// of this file defined left.fasta (convered into left.fastb), and column 14 
// defined right.{fasta,fastb}.
//
// The program defines an equivalence relation on pairs bubble.branch consisting of a 
// bubble id (1..14) and a branch id (1..2).  Call two pairs equivalent if they are 
// linked by perfectly aligning reads.  Obviously this is hopelessly intolerant of 
// error, but here's what you get for the orbits in this case:
//
// [1] 1.1
// [2] 1.2 2.1 3.2 4.1 5.2 6.2 7.2 8.2 9.1 11.2 12.1 13.2
// [3] 2.2
// [4] 3.1 4.2 5.1 6.1 7.1 8.1 9.2 11.1 12.2 13.1
// [5] 10.1
// [6] 10.2
// [7] 14.1
// [8] 14.2
//
// This is telling us that the HiC data define consistent phasing for 12/14 bubbles,
// leaving 2 bubbles unphased.  However these might be phased were one to extend the
// region or use the given data more intelligently, for example by using quality
// scores rather than requiring perfect alignments.
//
// The program is very inefficient.

// MakeDepend: library OMP
// MakeDepend: cflags OMP_FLAGS

#include "Basevector.h"
#include "Equiv.h"
#include "FetchReads.h"
#include "MainTools.h"
#include "pairwise_aligners/SmithWatFree.h"

int main( )
{
     vec<vec<vec<int>>> b = {
          {{33,32,30},{33,31,30}},
          {{30,34,28},{30,29,28}},
          {{28,27,18},{28,26,18}},
          {{18,17,8},{18,9,8}},
          {{8,7,6},{8,5,6}},
          {{6,4,2},{6,3,2}},
          {{2,1,39},{2,0,39}},
          {{39,42,40},{39,41,40}},
          {{40,38,37},{40,36,37}},
          {{37,35,25},{37,23,25}},
          {{25,24,21},{25,22,21}},
          {{21,20,16},{21,19,16}},
          {{16,15,13},{16,14,13}},
          {{13,12,10},{13,11,10}}
          };

     const int K = 80;
     vecbasevector A( "/wga/dev/jaffe/BroadCRD/aaa.final.fastb" );
     vecbasevector left( "left.fastb" ), right( "right.fastb" );
     int N = left.size( );
     equiv_rel eq( 2 * b.size( ) );

     vec<vec<int>> connections;
     #pragma omp parallel for
     for ( int i = 0; i < N; i++ )
     {    vec<int> bubble(2), branch(2), orient(2), e(2);
          vec<Bool> better(2);
          for ( int p = 0; p < 2; p++ )
          {    const vecbasevector& bases = ( p == 0 ? left : right );
               e[p] = 1000000000;
               better[p] = False;
               for ( int o = 0; o < 2; o++ )
               for ( int j = 0; j < b.isize( ); j++ )
               for ( int k = 0; k < 2; k++ )
               {    basevector x = A[ b[j][k][0] ];
                    x.resize( x.isize( ) - (K-1) );
                    x = Cat( x, A[ b[j][k][1] ] );
                    x.resize( x.isize( ) - (K-1) );
                    x = Cat( x, A[ b[j][k][2] ] );
                    if ( o == 1 ) x.ReverseComplement( );
                    int best_loc;
                    alignment a;
                    int errs = SmithWatFree( bases[i], x, best_loc, a );
                    if ( errs <= e[p] )
                    {    bubble[p] = j;
                         branch[p] = k;
                         orient[p] = o;
                         better[p] = ( errs < e[p] );
                         e[p] = errs;    }    }    }
          if ( better[0] && better[1] )
          {    
               if ( e[0] > 0 || e[1] > 0 ) continue;
               if ( bubble[0] == bubble[1] ) continue;

               #pragma omp critical
               {    // cout << "\n";

                    /*
                    for ( int p = 0; p < 2; p++ )
                    {    PRINT4( i, bubble[p], 
                              branch[p], e[p] );    }    }    }    }    }
                    */

                    /*
                    cout << bubble[0] << "." << branch[0]
                         << "\t" << bubble[1] << "." << branch[1] << endl;
                    */

                    int id1 = ( 2 * bubble[0] ) + branch[0];
                    int id2 = ( 2 * bubble[1] ) + branch[1];
                    vec<int> v = {id1,id2};
                    Sort(v);
                    connections.push_back(v);
                    eq.Join( id1, id2 );    }    }    }

     // Print connections and orbits.

     Sort(connections);
     cout << "\nCONNECTIONS:\n";
     for ( int i = 0; i < connections.isize( ); i++ )
     {    int j = connections.NextDiff(i);
          int n = j - i;
          int bubble1 = ( connections[i][0] ) / 2 + 1;
          int branch1 = ( connections[i][0] ) % 2 + 1;
          int bubble2 = ( connections[i][1] ) / 2 + 1;
          int branch2 = ( connections[i][1] ) % 2 + 1;
          cout << bubble1 << "." << branch1 << " " << bubble2 << "."
               << branch2 << " [" << n << "]\n";
          i = j - 1;    }
     vec<int> reps;
     eq.OrbitRepsAlt(reps);
     cout << "\nORBITS:\n";
     for ( int j = 0; j < reps.isize( ); j++ )
     {    vec<int> o;
          eq.Orbit( reps[j], o );
          Sort(o);
          cout << "[" << j+1 << "]";
          for ( int k = 0; k < o.isize( ); k++ )
          {    int bubble = o[k] / 2 + 1, branch = o[k] % 2 + 1;
               cout << " " << bubble << "." << branch;    }    
          cout << endl;    }    } 
               
