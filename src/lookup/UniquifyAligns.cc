// Copyright (c) 2000-2003 Whitehead Institute for Biomedical Research

// UniquifyAligns: given alignments of reads from an assembly to a genome
// (generated by QueryLookupTable), 
// (a) look for reads which align multiply to the same target with the same
//     orientation (and in no other way), and all starting witin 1000 of each other
//     on the genome - attempt to disambiguate them and to realign from scratch
//     to obtain a full length alignment;
// (b) look for situations where there is a read pair, neither read of which is 
//     placed uniquely, but such that there is only one placement of each read 
//     consistent with the pairing.  
// Produce as output a list of all the unique alignments, ordered by read id, 
// including those disambiguated in the ways just described.

// Alignments whose target id is not between FIRST_CONTIG and LAST_CONTIG are
// ignored.

// To accept a read pair alignment as unique, it must be within 
// MAX_DISCREP_TO_ACCEPT standard deviations of the predicted value, and there must
// not be any other pair alignments within MAX_DISCREP_TO_CONSIDER standard 
// deviations of the predicted value.

// THIS CURRENTLY HAS A HARD-CODED CALL TO QueryLookupTable in it.

#include <strstream>

#include "MainTools.h"
#include "FastIfstream.h"
#include "math/Functions.h"
#include "PackAlign.h"
#include "ReadPairing.h"

#include "lookup/LookAlign.h"
#include "lookup/LookupTable.h"

class placement {

     public:

     int ind1, ind2;
     float discrep;

     placement( ) { }
     placement( int ind1_arg,
		int ind2_arg,
		float discrep_arg )
       : ind1(ind1_arg),
	 ind2(ind2_arg),
	 discrep(discrep_arg)
     { }

};

class block_align {

     public:

     int offset;
     int id;
     int start;
     int length;

     block_align( ) { }
     block_align( int offset_arg,
		  int id_arg,
		  int start_arg,
		  int length_arg ) 
       : offset(offset_arg),
	 id(id_arg),
	 start(start_arg),
	 length(length_arg)
     { }

     int Start( ) const { return start; }
     int Stop( ) const { return start + length; }

     friend Bool operator<( const block_align& b1, const block_align& b2 )
     {    return b1.offset < b2.offset;    }

};

int main( int argc, char *argv[] )
{
     RunTime( );

     BeginCommandArguments;
     CommandArgument_String(PRE);
     CommandArgument_String(DATA);
     CommandArgument_String(RUN);
     CommandArgument_String(ALIGNMENT_FILES);
     CommandArgument_UnsignedInt(FIRST_CONTIG);
     CommandArgument_UnsignedInt(LAST_CONTIG);
     CommandArgument_Double(MAX_DISCREP_TO_CONSIDER);
     CommandArgument_Double(MAX_DISCREP_TO_ACCEPT);
     CommandArgument_Bool_OrDefault(VERBOSE, False);
     CommandArgument_String_OrDefault(LOGFILE, "UniquifyAligns.log" );
     EndCommandArguments;

     Ofstream( log, LOGFILE );

     // Load some assembly data.

     String run_dir = PRE + "/" + DATA + "/" + RUN;
     READ( run_dir + "/reads.pairto", vec<read_pairing>, pairs );
     int nreads = MastervecFileObjectCount( run_dir + "/reads.fastb" );

     // Read alignments.  Note that we may have aligns_count < aligns.size( ),
     // with the difference explained by junk at the end of aligns.

     vec< vec<int> > aligns_index(nreads);
     vec<String> aligns_files = AllFilesInSource(ALIGNMENT_FILES);
     int aligns_count;
     String line;
     vec<look_align_plus> aligns;
     for ( int pass = 1; pass <= 2; pass++ )
     {    if ( pass == 2 ) aligns.resize( aligns_count + aligns_count/100 );
          aligns_count = 0;
          for ( int i = 0; i < aligns_files.isize( ); i++ )
          {    fast_ifstream in( aligns_files[i] );
               while(1)
               {    getline( in, line );
                    if ( in.fail( ) ) break;
                    if ( !line.Contains( "QUERY", 0 ) ) continue;
                    if ( pass == 2 ) 
                    {    aligns[aligns_count].ReadParseable(line);
                         int t = aligns[aligns_count].target_id;
                         if ( t < (int) FIRST_CONTIG || t > (int) LAST_CONTIG ) 
                              continue;
                         int id = aligns[aligns_count].query_id;
                         aligns_index[id].push_back(aligns_count);    }
                    ++aligns_count;    }    }    }

     vec<int> realign;
     for ( int pass = 1; pass <= 2; pass++ )
     {    
          // In pass 2, realign reads having no full length alignment, and see if
          // we can recover a full length alignment.

          if ( pass == 2 )
          {    {    Ofstream( out, "FindMultipleAlignments.realign" );
                    for ( int i = 0; i < realign.isize( ); i++ )
                         out << realign[i] << "\n";    }
               fast_pipe_ifstream in( "QueryLookupTable K=12 "
                    "L=/wga/scratch20/LOOKUP/build34.lookup "
                    "SEQS=/wga/scratch23/Chimp/run/work/reads.fastb "
                    "SEQS_TO_PROCESS=FindMultipleAlignments.realign "
                    "PARSEABLE=True READABLE_BRIEF=False MF=5000" );
               while(1)
               {    getline( in, line );
                    if ( in.fail( ) ) break;
                    if ( !line.Contains( "QUERY", 0 ) ) continue;
                    if ( aligns_count == aligns.isize( ) )
                         FatalErr( "Ran out of space for alignments." );
                    aligns[aligns_count].ReadParseable(line);
                    if ( !aligns[aligns_count].FullLength( ) ) continue;
                    int t = aligns[aligns_count].target_id;
                    if ( t < (int) FIRST_CONTIG || t > (int) LAST_CONTIG ) continue;
                    int id = aligns[aligns_count].query_id;
                    aligns_index[id].push_back(aligns_count);
                    ++aligns_count;    }    }
               
          for ( int id = 0; id < nreads; id++ )
          {    if ( aligns_index[id].size( ) < 2 ) continue;

               Bool same_target = True, same_orientation = True;
               for ( int i = 1; i < aligns_index[id].isize( ); i++ )
               {    if ( aligns[ aligns_index[id][i] ].target_id
                         != aligns[ aligns_index[id][i-1] ].target_id )
                    {    same_target = False;    }
                    if ( aligns[ aligns_index[id][i] ].rc1
                         != aligns[ aligns_index[id][i-1] ].rc1 )
                    {    same_orientation = False;    }    }
               if ( !same_target && !same_orientation ) continue;

               Bool far_apart = False;
               for ( int i1 = 0; i1 < aligns_index[id].isize( ); i1++ )
               {    for ( int i2 = i1+1; i2 < aligns_index[id].isize( ); i2++ )
                    {    const look_align& la1 = aligns[ aligns_index[id][i1] ];
                         const look_align& la2 = aligns[ aligns_index[id][i2] ];
                         if ( Abs( la1.a.pos2( ) - la2.a.pos2( ) ) > 1000 )
                              far_apart = True;    }    }
               if (far_apart) continue;

               Bool have_full_length = False;
               for ( int i = 0; i < aligns_index[id].isize( ); i++ )
                    if ( aligns[ aligns_index[id][i] ].FullLength( ) )
                         have_full_length = True;

               if ( pass == 1 )
               {    if ( !have_full_length ) realign.push_back(id);
                    continue;    }
     
               log << "\n";
               for ( int i = 0; i < aligns_index[id].isize( ); i++ )
               {    const look_align& la = aligns[ aligns_index[id][i] ];
                    log << i << ": " << la.query_id << ( la.rc1 ? "rc" : "fw" ) 
                         << " vs " << la.target_id << ", " << la.mutations << " mis/"
                         << la.indels << " indels (of " << la.query_length
                         << "), from " << la.a.pos1( ) << "-" << la.a.Pos1( )
                         << " to " << la.a.pos2( ) << "-" << la.a.Pos2( ) 
                         << "\n";    }
     
               // Look for shared blocks between the alignments.
     
               int naligns = aligns_index[id].size( );
               log << "\n";
               static vec<block_align> blocks;
               blocks.clear( );
               vec<int> bases_aligned(naligns, 0);
               for ( int i = 0; i < naligns; i++ )
               {    const align& a = aligns[ aligns_index[id][i] ].a;
                    int p1 = a.pos1( ), p2 = a.pos2( );
                    for ( int j = 0; j < a.Nblocks( ); j++ )
                    {    if ( a.Gaps(j) > 0 ) p2 += a.Gaps(j);
                         if ( a.Gaps(j) < 0 ) p1 -= a.Gaps(j);
                         bases_aligned[i] += a.Lengths(j);
                         blocks.push_back( 
                              block_align( p2 - p1, i, p2, a.Lengths(j) ) );
                         log << "alignment " << i << ": offset = "
                              << p2 - p1 << ", aligns at " << p2 << "-" 
                              << p2 + a.Lengths(j)
                              << " (length = " << a.Lengths(j) << ")\n";
                         p1 += a.Lengths(j), p2 += a.Lengths(j);    }    }
               Sort(blocks);
               log << "\n";
               for ( int j = 0; j < blocks.isize( ); j++ )
               {    const block_align& b = blocks[j];
                    log << "offset = " << b.offset << ", align = " << b.id
                         << ", start = " << b.start << ", length = " << b.length
                         << "\n";    }
     
               static vec<int> discards;
               discards.clear( );
               for ( int i1 = 0; i1 < naligns; i1++ )
               {    for ( int i2 = i1+1; i2 < naligns; i2++ )
                    {    const look_align& la1 = aligns[ aligns_index[id][i1] ];
                         const look_align& la2 = aligns[ aligns_index[id][i2] ];
                         log << "comparing align " << i1 << " to " << i2 << "\n";
                         int bases_shared = 0;
                         for ( int j = 0; j < blocks.isize( ); j++ )
                         {    int k;
                              for ( k = j + 1; k < blocks.isize( ); k++ )
                                   if ( blocks[k].offset != blocks[j].offset ) break;
                              if ( k - j == 1 ) continue;
                              for ( int l1 = j; l1 < k; l1++ )
                              {    for ( int l2 = l1 + 1; l2 < k; l2++ )
                                   {    const block_align& b1 = blocks[l1];
                                        const block_align& b2 = blocks[l2];
                                        if ( b1.id != i1 && b1.id != i2 ) continue;
                                        if ( b2.id != i1 && b2.id != i2 ) continue;
                                        if ( b1.id == b2.id ) continue;
                                        int overlap = IntervalOverlap( 
                                             b1.Start( ), b1.Stop( ), 
                                             b2.Start( ), b2.Stop( ) );
                                        if ( overlap > 0 ) 
                                             bases_shared += overlap;    }    }
                              j = k - 1;    }
                         log << "bases aligned = (" << bases_aligned[i1] << ", " 
                              << bases_aligned[i2] << "), bases shared = " 
                              << bases_shared << "\n";
                         log << "unshared aligning bases = (" 
                              << bases_aligned[i1] - bases_shared << ", " 
                              << bases_aligned[i2] - bases_shared << ")\n";
     
                         // If la1.pos1-Pos1 is a subset of la2.pos1-Pos1
                         // and unshared_aligning_bases(la1) 
                         //                    < (0.5) unshared_aligning_bases(la2),
                         // then discard la1.pos1 >= la2.pos1.  (Also reverse.)
     
                         if ( la1.a.pos1( ) >= la2.a.pos1( ) 
                              && la1.a.Pos1( ) <= la2.a.Pos1( )
                              && bases_aligned[i1] - bases_shared 
                                   < 0.5 * (bases_aligned[i2] - bases_shared) )
                         {    log << "discard alignment " << i1 << "\n";
                              discards.push_back(i1);    }
                         if ( la2.a.pos1( ) >= la1.a.pos1( ) 
                              && la2.a.Pos1( ) <= la1.a.Pos1( )
                              && bases_aligned[i2] - bases_shared 
                                   < 0.5 * (bases_aligned[i1] - bases_shared) )
                         {    log << "discard alignment " << i2 << "\n";    
                              discards.push_back(i2);    }    }    }

               UniqueSort(discards);
               if ( discards.isize( ) == naligns - 1 )
               {    int undiscarded = -1;
                    for ( int j = 0; j < naligns; j++ )
                         if ( !BinMember( discards, j ) ) undiscarded = j;
                    log << "alignment " << undiscarded << " of " << id 
                         << " wins out over " << "all others\n";
                    if ( undiscarded != 0 ) aligns_index[id][0] 
                         = aligns_index[id][undiscarded];
                    aligns_index[id].resize(1);    }    }    }

     // Disambiguate pairs.

     for ( int i = 0; i < pairs.isize( ); i++ )
     {    const read_pairing& p = pairs[i];
          int id1 = p.id1, id2 = p.id2;
          if ( aligns_index[id1].size( ) <= 1 && aligns_index[id2].size( ) <= 1 )
               continue;
          static vec<placement> placements;
          placements.clear( );
          for ( int j1 = 0; j1 < aligns_index[id1].isize( ); j1++ )
          {    int ind1 = aligns_index[id1][j1];
               const look_align_plus& la1 = aligns[ind1];
               for ( int j2 = 0; j2 < aligns_index[id2].isize( ); j2++ )
               {    int ind2 = aligns_index[id2][j2];
                    const look_align_plus& la2 = aligns[ind2];
                    if ( la1.target_id != la2.target_id ) continue;
                    if ( la1.rc1 == la2.rc1 ) continue;
                    int sep;
                    if ( !la1.rc1 ) sep = la2.a.pos2( ) - la1.a.Pos2( );
                    else sep = la1.a.pos2( ) - la2.a.Pos2( );
                    if ( sep < 0 ) continue;
                    float discrep = float( Abs( sep - p.sep ) ) / float(p.sd);
                    if ( discrep > MAX_DISCREP_TO_CONSIDER ) continue;
                    if ( discrep > MAX_DISCREP_TO_ACCEPT ) goto fail;
                    placements.push_back( 
                         placement( ind1, ind2, discrep ) );    }    }
          if ( placements.size( ) == 1 )
          {    const placement& x = placements[0];
               // log << "pairing " << i << ", discrep = " << x.discrep << "\n";
               if ( VERBOSE && aligns_index[id1].size( ) > 1 )
                    log << "uniquifying alignment of read " << id1
                         << " using its pairing to read " << id2 << "\n";
               if ( VERBOSE && aligns_index[id2].size( ) > 1 )
                    log << "uniquifying alignment of read " << id2
                         << " using its pairing to read " << id1 << "\n";
               aligns_index[id1].resize(1), aligns_index[id2].resize(1);
               aligns_index[id1][0] = x.ind1, aligns_index[id2][0] = x.ind2;    }
          fail: continue;    }

     // Output unique alignments.

     for ( int i = 0; i < nreads; i++ )
     {    if ( aligns_index[i].size( ) == 1 )
          {    ForceAssertEq( i, aligns[ aligns_index[i][0] ].query_id );
               aligns[ aligns_index[i][0] ].WriteParseable(cout);    }    }   }
