#!/usr/bin/env python

###############################################################################
#                    SOFTWARE COPYRIGHT NOTICE AGREEMENT                      #
#        This software and its documentation are copyright (2010) by the      #
#    Broad Institute.  All rights are reserved.  This software is supplied    #
#    without any warranty or guaranteed support whatsoever. The Broad         #
#    Institute is not responsible for its use, misuse, or functionality.      #
###############################################################################

# This program accepts a series of QLTOUT and FASTA pairs, where each QLTOUT
# was generated by aligning the reads in its associated FASTA. If only
# one QLTOUT and one FASTA are provided, a tab-delimited table of per-read
# alignment errors are written. If multiple QLTOUT and FASTA pairs are
# provided, a table of the errors for the reads that appear in all
# data sets (read identities determined by FASTA read names) is produced,
# with a set of columns for each QLTOUT. The program takes care of any
# differences in read-ordering between different QLTOUT and FASTA pairs.

# Original author: Michael G. Ross <mgross@broadinstitute.org>

import re
import sys
from BroadCRD.util.fasta import readFasta

if len(sys.argv) == 1 or (len(sys.argv) - 1) % 2 != 0:
    print >>sys.stderr, ('Usage: ' + sys.argv[0] + ' qltout1 fasta1 '
        '[qltout2 fasta2] [qltout3 fasta3] ...')
    exit(1)

output_reads = []
output_read_set = set()
data_sets = int((len(sys.argv) - 1) / 2)
for n in range(data_sets):
    qltout_filename = sys.argv[n * 2 + 1]
    fasta_filename = sys.argv[n * 2 + 2]

    readnames = list(map(lambda read_name_pair: read_name_pair[0],
                         readFasta(fasta_filename)))
    output_reads.append({})
    with open(qltout_filename, 'r') as qltout_file:
        for qltout_line in qltout_file:
            qmatch = re.match('^QUERY\s+(\d+)', qltout_line)
            if qmatch:
                query = int(qmatch.group(1))
                q_els = qltout_line.split('\t')
                read_length = int(q_els[4])
                num_blocks = int(q_els[10])
                mismatches = 0
                indels = 0
                for b in range(11, 11 + num_blocks * 3, 3):
                    indels += abs(int(q_els[b]))
                    mismatches += int(q_els[b + 2])
                output_reads[n][readnames[query]] = (query, read_length,
                                                     mismatches, indels)

    output_read_set.update(set(output_reads[n].keys()))

output_read_list = list(output_read_set)
output_read_list.sort()


print 'READ\t',
for output in output_reads:
    print 'QUERY\tLENGTH\tMISMATCH\tINDEL\tTOTERR\t',
print
for read in output_read_list:
    skip_read = False
    for output in output_reads:
        if not read in output:
            skip_read = True
            break
    if skip_read:
        continue
    print read + '\t',
    for output in output_reads:
        if read in output:
            readinfo = output[read]
            print (str(readinfo[0]) +
                '\t' + str(readinfo[1]) +
                '\t' + str(readinfo[2]) +
                '\t' + str(readinfo[3]) +
                '\t' + str(readinfo[2] + readinfo[3]) + '\t'),
        else:
            print '\t\t'* 5,
    print

exit(0)
