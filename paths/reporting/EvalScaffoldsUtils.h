///////////////////////////////////////////////////////////////////////////////
//                   SOFTWARE COPYRIGHT NOTICE AGREEMENT                     //
//       This software and its documentation are copyright (2010) by the     //
//   Broad Institute.  All rights are reserved.  This software is supplied   //
//   without any warranty or guaranteed support whatsoever. The Broad        //
//   Institute is not responsible for its use, misuse, or functionality.     //
///////////////////////////////////////////////////////////////////////////////

#ifndef EVAL_SCAFFOLDS_UTILS_H
#define EVAL_SCAFFOLDS_UTILS_H

#include "Vec.h"
#include "PrettyPrintTable.h"
#include "SupersHandler.h"
#include "lookup/LookAlign.h"
#include "paths/reporting/CGapStats.h"

/**
 * struct SPlacement
 *
 * Placement of a stretch of super (from a begin cgpos to an end cgpos) onto
 * a target sequence.
 */
struct SPlacement {

public:
  
  SPlacement( );
  
  SPlacement( int query, int pos1, int pos2 );

  SPlacement( const look_align_plus &hit1, const look_align_plus &hit2,
	      int super_id, int pos1, int pos2 );
  
  SPlacement( int target, int query, bool rc,
	      pair<int,int> twin, pair<int,int> spos );

  void SetFromLookAligns( const look_align_plus &hit1,
			  const look_align_plus &hit2,
			  const int super_id,
			  const int pos1, const int pos2 );
			  
  bool MergesWith( const double discrepancy, 
		   const SPlacement &other,
		   const shandler &supers );

  void PrintLegend( ostream &out ) const;
  
  void PrintInfo( const shandler &supers, vec<String> &info ) const;

  friend bool operator< ( const SPlacement &left, const SPlacement &right );
  
  
public:
  
  int target_;          // id of target
  int query_;           // id of super (query)
  bool rc_;             // if this stretch of super lies rc on target
  pair<int,int> twin_;  // window of placement on target
  pair<int,int> spos_;  // begin/end cgpos on super for this stretch
  
};

/**
 * AreConsistent
 *
 * It returns true if the given hits are consistent with each other.
 * If weak = true, skip the test for the stretchiness of the gap
 * between the two hits.
 */
bool AreConsistent( const look_align_plus &hit1,
		    const look_align_plus &hit2,
		    const shandler &supers,
		    String &info,
		    bool weak = false,
		    CGapStats *gap_stats = 0 );

/**
 * SuperChain
 *
 * Build a chain of hits for the given super. Some bookkeping is due
 * to the fact that a contig may own multiple aligments.
 */
void SuperChain( const int super_id,
		 const shandler &supers,
		 const vec<look_align_plus> &hits,
		 const vec< vec<int> > &edge2hits,
		 vec<int> &chain );

/**
 * DigestChain
 *
 * Compactify a chain into blocks of consistent placements. Some
 * heuristics are involved to get rid of noise in the input chain.
 * Output is left empty if no contig in super aligns.
 */
void DigestChain( const shandler &supers,
		  const vec<look_align_plus> &hits,
		  const vec<int> &chain,
		  vec<SPlacement> &placs );

/**
 * PrintChain
 *
 * Print a chain of hits as generated by SuperChain.
 */
void PrintChain( const shandler &supers,
		 const vec<look_align_plus> &hits,
		 const vec<int> &chain,
		 int &n_local_inversions,
		 ostream &out );

/**
 * ChainGaps
 *
 * Fill gap_stats with information needed to report on gaps statistics.
 */
void ChainGaps( const shandler &supers,
		const vec<look_align_plus> &hits,
		const vec<int> &chain,
		CGapStats &gap_stats );

#endif
