/////////////////////////////////////////////////////////////////////////////
//                   SOFTWARE COPYRIGHT NOTICE AGREEMENT                   //
//       This software and its documentation are copyright (2007) by the   //
//   Broad Institute/Massachusetts Institute of Technology.  All rights    //
//   are reserved.  This software is supplied without any warranty or      //
//   guaranteed support whatsoever. Neither the Broad Institute nor MIT    //
//   can be responsible for its use, misuse, or functionality.             //
/////////////////////////////////////////////////////////////////////////////

#include "CoreTools.h"
#include "MainTools.h"
#include "Basevector.h"
#include "LocsHandler.h"
#include "PairsHandler.h"
#include "STLExtensions.h"

/**
 * FillFragmentSim
 *
 * Takes in input simulation data generated by SimulateReads and
 * generates statistics on fragments that can be filled by overlapping
 * reads. A fragment is filled if it exists at least one read
 * overlapping both ends of the fragment by MIN_OVERLAP bases.  Only
 * fragments with both given and observed separations <= MAX_SEP are
 * tested for filling.
 *
 * MIN_OVERLAP: filling reads must overlap the two end reads by this much
 * MAX_SEP: do not try to fill reads with separation bigger than this
 */
int main( int argc, char *argv[] )
{
  RunTime( );
  
  BeginCommandArguments;
  CommandArgument_String( PRE );
  CommandArgument_String( DATA );
  CommandArgument_String( RUN );
  CommandArgument_Int_OrDefault( MIN_OVERLAP, 30 );
  CommandArgument_Int_OrDefault( MAX_SEP, 50 );
  EndCommandArguments;

  // Dir and file names.
  String data_dir = PRE + "/" + DATA;
  String run_dir = data_dir + "/" + RUN;

  String genomesize_file = data_dir + "/genome.size";
  String genome_file = data_dir + "/genome.fastb";

  String bases_file = run_dir + "/reads.fastb";
  String pairs_file = run_dir + "/reads.pairto";
  String cheatlocs_file = run_dir + "/reads.ref.locs";
  String log_file = run_dir + "/FillFragmentSim.log";
  
  // Log stream.
  ofstream log( log_file.c_str( ) );
  PrintCommandPretty( log );
  log << "MIN_OVERLAP: " << MIN_OVERLAP << "\n"
      << "MAX_SEP:     " << MAX_SEP << "\n"
      << "\n"
      << "Window win is defined as [end1-MIN_OVERLAP,start2+MIN_OVERLAP),\n"
      << "where end1 is the end of the left read, and start2 the start of\n"
      << "the right read.\n"
      << "\n";
  
  // Load.
  int n_reads = MastervecFileObjectCount( bases_file );
  int n_contigs = MastervecFileObjectCount( genome_file );
  longlong gsize = StringOfFile( genomesize_file, 1 ).Int( );
  
  cout << Date( ) << ": loading pairs" << endl;
  phandler pairs( n_reads, pairs_file );
  
  cout << Date( ) << ": loading locs" << endl;
  lhandler locs( n_reads, n_contigs, cheatlocs_file );

  // Parse pairs.
  int dotter = 100000;

  cout << Date( ) << ": parsing "
       << locs.Size( ) << " pairs (.="
       << dotter << " pairs):\n";

  int n_tested = 0;  // count for pairs tested for filling
  int n_filled = 0;  // how many pairs were filled
  vec<int> lens;     // lengths of filled fragments

  lens.reserve( pairs.Pairs( ).size( ) );

  for (int pair_id=0; pair_id<pairs.Pairs( ).isize( ); pair_id++) {
    if ( pair_id % dotter == 0 ) Dot( cout, pair_id / dotter );

    // Only test pairs with separation <= MAX_SEP.
    String str_discard = "";
    if ( pairs[pair_id].sep > MAX_SEP )
      str_discard = "given sep = " + ToString( pairs[pair_id].sep );
    
    // Insert has not been uniquely placed.
    int id1 = pairs[pair_id].id1;
    int id2 = pairs[pair_id].id2;
    const read_location *plac1 = locs.GetPlacement( id1 );
    const read_location *plac2 = locs.GetPlacement( id2 );
    if ( str_discard == "" && !( plac1 || plac2 ) )
      str_discard = "insert not uniquely placed";
    
    // End reads placed on different contigs.
    if ( str_discard == "" && ( plac1->Contig( ) != plac2->Contig( ) ) )
      str_discard = "end reads on different contigs";

    // Observed separation is > MAX_SEP.
    int start2 = plac2->StartOnContig( );
    int end1 = 1 + plac1->StopOnContig( );
    if ( str_discard == "" && ( start2 - end1 > MAX_SEP ) )
      str_discard = "observed sep = " + ToString( start2 - end1 );
    
    // Also reject inserts pointing away from each other.
    int start1 = plac1->StartOnContig( );
    if ( str_discard == "" && ( start2 < start1 ) )
      str_discard = "invalid insert (reads point away from each other)";

    // Print logging info for discarded pairs.
    if ( str_discard != "" ) {
      log << "discard p_" << pair_id
	  << " (" << str_discard
	  << "): id1=" << id1
	  << ", id2=" << id2
	  << " start=" << start1
	  << ", end=" << 1 + plac2->StopOnContig( )
	  << "\n";
      continue;
    }

    // Test this pair.
    n_tested++;
    
    int begin = plac1 - & (locs[0] );
    bool filler_found = false;
    for (int ii=begin; ii<locs.Size( ); ii++) {
      if ( locs[ii].Contig( ) != plac1->Contig( ) ) break;
      if ( locs[ii].StartOnContig( ) > end1 - MIN_OVERLAP ) break;
      if ( 1 + locs[ii].StopOnContig( ) >= start2 + MIN_OVERLAP ) {
	filler_found = true;
	break;
      }
    }

    // Log failure to fill.
    if ( filler_found ) {
      lens.push_back( 1 + plac2->StopOnContig( ) - start1 );
      n_filled++;
      continue;
    }
    
    log << "failed p_" << pair_id
	<< " r_[" << id1
	<< ", " << id2
	<< " insert_[" << start1
	<< "," << 1 + plac2->StopOnContig( )
	<< ") win_[" << end1 - MIN_OVERLAP
	<< "," << start2 + MIN_OVERLAP
	<< ") sepsize=" << start2 - end1
	<< "\n";
  }
  cout << endl;
  log << endl;

  // Overall stats.
  cout << "\nSending output to " << log_file << "\n" << endl;
  
  longlong tot_fill_len = BigSum( lens );
  double ratio = 100.0 * SafeQuotient( n_filled, pairs.Pairs( ).isize( ) );
  double cov = SafeQuotient( tot_fill_len, gsize );
  String str_ratio = ToString( ratio, 2 ) + "%";
  String str_cov = ToString( cov, 1 ) + "x";

  log << "\n"
      << "OVERALL STATISTICS\n"
      << "\n"
      << "pairs in input:   " << pairs.Pairs( ).size( ) << "\n"
      << "pairs tested [1]: " << n_tested << "\n"
      << "pairs filled:     " << n_filled << "\n"
      << "\n"
      << "percent filled, with respect to total:     " << str_ratio << "\n"
      << "coverage in terms of filled fragments [2]: " << str_cov << "\n"
      << "\n"
      << "[1] some pairs are not tested for filling (for example if their\n"
      << "    separation exceeds the given MAX_SEP).\n"
      << "\n"
      << "[2] based on an estimated genome size of " << gsize << ",\n"
      << "    as specified in the file \"genome.size\".\n"
      << "\n" << flush;
  
  // Done.
  cout << Date( ) << ": done" << endl;
  log.close( );
  
}
