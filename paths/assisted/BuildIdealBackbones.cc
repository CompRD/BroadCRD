///////////////////////////////////////////////////////////////////////////////
//                   SOFTWARE COPYRIGHT NOTICE AGREEMENT                     //
//       This software and its documentation are copyright (2012) by the     //
//   Broad Institute.  All rights are reserved.  This software is supplied   //
//   without any warranty or guaranteed support whatsoever. The Broad        //
//   Institute is not responsible for its use, misuse, or functionality.     //
///////////////////////////////////////////////////////////////////////////////

#include "MainTools.h"
#include "Basevector.h"
#include "Superb.h"
#include "VecUtilities.h"
#include "lookup/LookAlign.h"
#include "math/NStatsTools.h"
#include "paths/assisted/FilterAlignsForAssisting.h"
#include "util/RunCommand.h"

/**
 * BuildIdealBackbones
 *
 * Build ideal backbones from the aligns of selected unibases onto a
 * reference (as generated by PrepareUnibases). Aligns are not
 * filtered. Notice that multiply aligned unibases are copied (hence
 * different contigs may map back to the same unibase id).
 *   
 * INPUT:
 *   <HEAD_IN>.fastb
 *   <HEAD_IN>.on_reference.qlt
 *
 * OUTPUT:
 *   <HEAD_OUT>.contigs.fastb (contigs)
 *   <HEAD_OUT>.superb (supers)
 *   <HEAD_OUT>.orig_ids (map to original ids - signed for orient.)
 *
 * OTHER ARGS:
 *   RATIO_DEV: set gaps devs to gap_size * RATIO_DEV (if >= MIN_DEV)
 *   MIN_DEV: min value for gaps devs
 *   MIN_GAP: start a new super if unibases overlap too much
 *   MAX_GAP: start a new super if two unibases are too distant apart
 *   FILTER_BIG_GAPS: run FilterBigGaps (see FilterAlignsForAssisting.h)
 */
int main( int argc, char *argv[] )
{
  RunTime( );

  BeginCommandArguments;
  CommandArgument_String( HEAD_IN );
  CommandArgument_String( HEAD_OUT );
  CommandArgument_Double_OrDefault( RATIO_DEV, 0.15 );
  CommandArgument_Int_OrDefault( MIN_DEV, 10 );
  CommandArgument_Int_OrDefault( MIN_GAP, -2000 );
  CommandArgument_Int_OrDefault( MAX_GAP, 6500 );
  CommandArgument_Bool_OrDefault( FILTER_BIG_GAPS, True );
  EndCommandArguments;

  // File names.
  String in_bases_file = HEAD_IN + ".fastb";
  String in_aligns_file = HEAD_IN + ".on_reference.qlt";
  String in_index_file = HEAD_IN + ".orig.ids";

  String out_bases_file = HEAD_OUT + ".contigs.fastb";
  String out_supers_file = HEAD_OUT + ".superb";
  String out_index_file = HEAD_OUT + ".orig.ids";
  String log_file = HEAD_OUT + ".BuildIdealBackbones.log";

  vec<String> needed;
  needed.push_back( in_bases_file );
  needed.push_back( in_aligns_file );
  needed.push_back( in_index_file );
  if ( ! CheckFilesExist( needed, &cout ) ) return 1;
  
  Mkpath( Dirname( HEAD_OUT ) );

  // Log stream
  ofstream log( log_file.c_str( ) );
  PrintCommandPretty( log );
  cout << "\n Sending log to " << log_file << "\n" << endl;

  // Load.
  log << Date( ) << ": loading unibases" << endl;
  vecbvec unibases( in_bases_file.c_str( ) );

  log << Date( ) << ": loading and sorting aligns" << endl;
  vec<look_align> aligns;
  LoadLookAligns( in_aligns_file, aligns );
  order_lookalign_TargetBeginEnd sorter;
  sort( aligns.begin( ), aligns.end( ), sorter );

  log << Date( ) << ": loading index map\n" << endl;
  READ( in_index_file, vec<int>, orig_ids );
  
  // Filter aligns.
  if ( FILTER_BIG_GAPS )
    FilterBigGaps( MIN_GAP, MAX_GAP, aligns, &log );
  
  // Output data.
  vecbvec contigs;
  vec<superb> supers;
  vec<int> out_map;
  
  // Reserve memory.
  vec<int> n_placements( unibases.size( ), 0 );
  for (size_t ii=0; ii<aligns.size( ); ii++)
    n_placements[aligns[ii].query_id] += 1;

  size_t n_contigs = 0;
  for (size_t ii=0; ii<n_placements.size( ); ii++)
    n_contigs += Max( 1, n_placements[ii] );

  contigs.reserve( n_contigs );
  out_map.reserve( n_contigs );
  
  // Build chains.
  vec< vec<int> > chains;
  for (size_t ii=0; ii<aligns.size( ); ii++) {
    int gap = 0;
    if ( ii > 0 ) gap = AlignsGap( aligns[ii-1], aligns[ii] );
    
    bool is_new = ( chains.size( ) < 1 || gap < MIN_GAP || gap > MAX_GAP );
    
    if ( is_new ) chains.push_back( vec<int>( 1, ii ) );
    else chains[chains.size( )-1].push_back( ii );
  }    

  // From chains to supers and contigs.
  supers.reserve( chains.size( ) );
  for (int ii=0; ii<chains.isize( ); ii++) {
    for (int jj=0; jj<chains[ii].isize( ); jj++) {
      const look_align &al = aligns[ chains[ii][jj] ];
      int uid = orig_ids[al.query_id];
      int tid = al.target_id;
      bool rc = al.Rc1( );
      bvec rcbases;
      if ( rc ) {
	rcbases = unibases[al.query_id];
	rcbases.ReverseComplement( );
      }
      const bvec &bases = rc ? rcbases : unibases[al.query_id];
      
      int cid = contigs.size( );
      int clen = bases.size( );
      if ( jj == 0 ) {
	superb new_super;
	new_super.PlaceFirstTig( cid, clen );
	supers.push_back( new_super );
      }
      else {
	const look_align &pal = aligns[ chains[ii][jj-1] ];
	int gap = AlignsGap( pal, al );
	int dev = Max( MIN_DEV, (int)( (double)gap * RATIO_DEV ) );
	supers[supers.size( )-1].AppendTig( cid, clen, gap, dev );
      }

      contigs.push_back( bases );
      out_map.push_back( rc ? -uid-1 : uid );
    }
  }

  // Add unmapped unibases.
  int n_mapped = supers.size( );
  for (int ii=0; ii<n_placements.isize( ); ii++) {
    if ( n_placements[ii] > 0 ) continue;
    const bvec &bases = unibases[ii];
    int cid = contigs.size( );
    int clen = bases.size( );
    
    superb new_super;
    new_super.PlaceFirstTig( cid, clen );
    supers.push_back( new_super );
    contigs.push_back( bases );
    out_map.push_back( ii );
  }
  
  // Detailed contigs table.
  vec< vec<String> > table;
  vec<String> line = MkVec( String( " id" ),
			    String( "len" ),
			    String( "super" ),
			    String( "placement" ),
			    String( "gap / reason of termination" ) );
  table.push_back( line );
  
  for (int ii=0; ii<supers.isize( ); ii++) {
    for (int jj=0; jj<supers[ii].Ntigs( ); jj++) {
      String str_len = ToString( supers[ii].Len( jj ) );
      String str_placement = "unmapped";
      if ( ii < chains.isize( ) ) {
	const look_align &al = aligns[ chains[ii][jj] ];
	int begin = al.pos2( ) - al.pos1( );
	int end = al.Pos2( ) + ( al.query_length - al.Pos1( ) );
	str_len = ToString( end - begin );   // override len in some cases
	str_placement
	  = "t" + ToString ( al.target_id )
	  + "_[" + ToString( begin ) + ", " + ToString( end ) + ")";
      }
      
      String str_termin = "na";
      if ( ii < chains.isize( ) ) {
	if ( jj < supers[ii].Ntigs( )-1 ) {
	  str_termin
	    = ToString( supers[ii].Gap( jj ) ) + " +/- "
	    + ToString( supers[ii].Dev( jj ) );
	}
	else {
	  if ( ii < chains.isize( ) - 1 ) {
	    const look_align &left = aligns[ chains[ii].back( ) ];
	    const look_align &right = aligns[ chains[ii+1].front( ) ];
	    if ( left.target_id != right.target_id )
	      str_termin = "different target id";
	    else {
	      int gap = AlignsGap( left, right );
	      if ( gap < MIN_GAP )
		str_termin = "excessive overlap (" + ToString(-gap) + " bases)";
	      else
		str_termin = "large gap (" + ToString(gap) + " bases)";
	    }
	  }
	  else
	    str_termin = "last mapped super";
	}
      }      
      
      String str_sup
	= ToString( ii ) + "."
	+ ToString( jj ) + "/"
	+ ToString( supers[ii].Ntigs( ) - 1 );

      line = MkVec( ToString( supers[ii].Tig( jj ) ),
		    str_len,
		    str_sup,
		    str_placement,
		    str_termin );
      table.push_back( line );
    }
  }
  
  log << "DETAILED CONTIGS PLACEMENT\n\n";
  PrintTabular( log, table, 3, "rrrl" );
  log << endl;
  
  // Overall supers table.
  table.clear( );
  line = MkVec( String( " id" ),
		String( "ntigs" ),
		String( "length" ),
		String( "placement" ),
		String( "reason of termination" ) );
  table.push_back( line );

  for (int ii=0; ii<supers.isize( ); ii++) {
    String str_placement = "unmapped";
    if ( ii < chains.isize( ) ) {
      const look_align &first_al = aligns[ chains[ii].front( ) ];
      const look_align &last_al = aligns[ chains[ii].back( ) ];
      int begin = first_al.pos2( ) - first_al.pos1( );
      int end = last_al.Pos2( ) + ( last_al.query_length - last_al.Pos1( ) );
      str_placement
	= "t" + ToString ( first_al.target_id )
	+ "_[" + ToString( begin ) + ", " + ToString( end ) + ")";
    }

    String str_termin = "na";
    if ( ii < chains.isize( ) - 1 ) {
      const look_align &left = aligns[ chains[ii].back( ) ];
      const look_align &right = aligns[ chains[ii+1].front( ) ];
      if ( left.target_id != right.target_id )
	str_termin = "different target id";
      else {
	int gap = AlignsGap( left, right );
	if ( gap < MIN_GAP )
	  str_termin = "excessive overlap (" + ToString( -gap ) + " bases)";
	else
	  str_termin = "large gap (" + ToString( gap ) + " bases)";
      }
    }
    else if ( ii == chains.isize( ) - 1 )
      str_termin = "last mapped super";

    line = MkVec( ToString( ii ),
		  ToString( supers[ii].Ntigs( ) ),
		  ToString( supers[ii].TrueLength( ) ),
		  str_placement,
		  str_termin );
    table.push_back( line );
  }
  
  log << "OVERALL SUPERS PLACEMENT\n\n";
  PrintTabular( log, table, 3, "rrrrl" );
  log << endl;

  // Overall stats.
  vec<int> slens;
  slens.reserve( supers.size( ) );
  for (int ii=0; ii<supers.isize( ); ii++)
    slens.push_back( supers[ii].TrueLength( ) );
  sort( slens.begin( ), slens.end( ) );

  log << "OVERALL STATS\n"
      << "\n";
  PrintBasicNStats( "supers", slens, log );
  log << endl;

  // Save.
  log << Date( ) << ": saving ideal backbones" << endl;
  contigs.WriteAll( out_bases_file );
  WriteSuperbs( out_supers_file, supers );
  WRITE( out_index_file, out_map );

  // Done.
  cout << Date( ) << ": BuildIdealBackbones done" << endl;
  log << Date( ) << ": BuildIdealBackbones done" << endl;
  log.close( );

}
