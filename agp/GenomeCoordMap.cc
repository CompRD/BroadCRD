// Copyright (c) 2004 Broad Institute/Massachusetts Institute of Technology

// Take as input alignments from a reference genome R to a draft genome X, which
// is an Arachne assembly, and an AGP for X (as generated by CreateStandardOutputs).

// Create a function taking as input a genome R AGP-object (typically a chromosome),
// and a coordinate range on this object, and returning ....

#include <map>
#include <strstream>

#include <ctype.h>

#include "CoreTools.h"
#include "FastIfstream.h"
#include "agp/GenomeCoordMap.h"
#include "math/HoInterval.h"
#include "system/file/FileReader.h"
#include "system/file/FileWriter.h"

// A scaffold_to encodes a gap-free aligning segment between some bases on a
// "scaffold" and some bases on another "object".   Aside from the "source"
// member, this is no different from a "balign".  (And given time, I would rewrite
// this in terms of balign.)

class scaffold_to {

     public:

     int scaffold_id, obj_id;
     ho_interval scaffold_range, obj_range;
     Bool rc;
     int source;

     scaffold_to( ) { }
     scaffold_to( int scaffold_id_arg,
		  int obj_id_arg,
		  ho_interval scaffold_range_arg,
		  ho_interval obj_range_arg,
		  Bool rc_arg,
		  int source_arg )
       : scaffold_id(scaffold_id_arg),
	 obj_id(obj_id_arg),
	 scaffold_range(scaffold_range_arg),
	 obj_range(obj_range_arg),
	 rc(rc_arg),
	 source(source_arg) 
     { }

     friend Bool operator<( const scaffold_to& s1, const scaffold_to& s2 )
     {    if ( s1.scaffold_id < s2.scaffold_id ) return True;
          if ( s1.scaffold_id > s2.scaffold_id ) return False;
          return s1.scaffold_range.Start( ) < s2.scaffold_range.Start( );    }

};

Bool genome_coordinate_map::Valid( Bool verbose )
{    Bool answer = True;
     for ( int i = 1; i < RtoX.isize( ); i++ )
     {    if ( RtoX[i].id1 == RtoX[i-1].id1 
               && RtoX[i-1].range1.Stop( ) > RtoX[i].range1.Start( ) )
          {    answer = False;
               if (verbose)
               {    cout << "\nsee overlap:\n";
                    Print( cout, i - 1 ), Print( cout, i );    }    }    }
     return answer;    }

void genome_coordinate_map::Read( const String& fn )
{    FileReader fr(fn.c_str());
     int names_count, names_max;
     fr.read( &names_count, sizeof(int) );
     fr.read( &names_max, sizeof(int) );
     vec<char> bs(names_max);
     Rchr.resize(names_count);
     for ( int i = 0; i < names_count; i++ )
     {    fr.read( &bs[0], names_max );
          Rchr[i] = &bs[0];    }
     int nmap;
     fr.read( &nmap, sizeof(int) );
     RtoX.resize(nmap);
     fr.read( &RtoX[0], nmap * sizeof(balign) );
     index_.reserve( Rchr.size( ) + 1 );
     index_.push_back(0);
     for ( int i = 1; i < RtoX.isize( ); i++ )
          if ( RtoX[i].id1 != RtoX[i-1].id1 ) index_.push_back(i);
     index_.push_back( RtoX.size( ) );    }

void genome_coordinate_map::Write( const String& fn )
{    int names_count = Rchr.size( ), names_max = 0;
     for ( int i = 0; i < names_count; i++ )
          names_max = Max( names_max, (int) Rchr[i].size( ) );
     ++names_max;
     FileWriter fw(fn);
     fw.write( &names_count, sizeof(int) );
     fw.write( &names_max, sizeof(int) );
     vec<char> bytes(names_max);
     for ( int i = 0; i < names_count; i++ )
     {    for ( int j = 0; j < names_max; j++ )
               bytes[j] = 0;
          for ( int j = 0; j < (int) Rchr[i].size( ); j++ )
               bytes[j] = Rchr[i][j];
          fw.write( &bytes[0], names_max );    }
     int RX_size = RtoX.size( );
     fw.write( &RX_size, sizeof(int) );
     fw.write( &RtoX[0], RX_size * sizeof(balign) );
     fw.close();    }

void genome_coordinate_map::Print( ostream& out, int i )
{    const balign& s = RtoX[i];
     out << Rchr[s.id1] << "." << s.range1 << " <--> " << s.id2 << "." 
          << s.range2 << " (" << (s.rc ? "rc" : "fw") << ")\n";    }

void genome_coordinate_map::Lookup( 
     /* inputs: */ const String& chr, int pos1, int pos2,
     /* outputs: */ Bool& OK, int& indent1, int& indent2,
                    int& tig1, int& tig2, int& tig1_pos, int& tig2_pos,
                    Bool& tig1_rc, Bool& tig2_rc )
{    int id = BinPosition( Rchr, chr );
     if ( id < 0 || index_[id] == index_[id+1] || pos1 > pos2 )
     {    OK = False;
          return;    }
     int first = index_[id], last = index_[id+1] - 1, next, final;
     while(1)
     {    if (first == last)
          {    final = last;
               break;    }
          next = first + (last - first) / 2;
          if ( pos1 < RtoX[next].Start1( ) ) last = next;
          else if ( RtoX[next].Start1( ) < pos1 ) first = next + 1;
          else
          {    final = next;
               break;    }    }
     if ( final > index_[id] && Member( RtoX[final-1].range1, pos1 ) ) --final;
     if ( final < index_[id+1] - 1 && Member( RtoX[final+1].range1, pos1 ) ) ++final;

     while( pos1 >= RtoX[final].Stop1( ) )
     {    if ( final == index_[id+1] - 1 )
          {    OK = False;
               return;    }
          ++final;    }

     tig1 = RtoX[final].id2;
     tig1_rc = RtoX[final].rc;

     if ( pos1 < RtoX[final].Start1( ) ) 
     {    indent1 = RtoX[final].Start1( ) - pos1;
          pos1 += indent1;    
          if ( !tig1_rc ) tig1_pos = RtoX[final].Start2( );
          else tig1_pos = RtoX[final].Stop2( ) - 1;    }
     else
     {    indent1 = 0;
          if ( !tig1_rc ) 
               tig1_pos = RtoX[final].Start2( ) + pos1 - RtoX[final].Start1( );
          else 
          {    tig1_pos = RtoX[final].Stop2( ) 
                    - 1 - ( pos1 - RtoX[final].Start1( ) );    }    }

     first = index_[id], last = index_[id+1] - 1;
     while(1)
     {    if (first == last)
          {    final = last;
               break;    }
          next = first + (last - first) / 2;
          if ( pos2 < RtoX[next].Start1( ) ) last = next;
          else if ( RtoX[next].Start1( ) < pos2 ) first = next + 1;
          else
          {    final = next;
               break;    }    }
     if ( final > index_[id] && Member( RtoX[final-1].range1, pos2 ) ) --final;
     if ( final < index_[id+1] - 1 && Member( RtoX[final+1].range1, pos2 ) ) ++final;

     while( pos2 < RtoX[final].Start1( ) )
     {    if ( final == 0 )
          {    OK = False;
               return;    }
          --final;    }

     tig2 = RtoX[final].id2;
     tig2_rc = RtoX[final].rc;

     if ( pos2 >= RtoX[final].Stop1( ) )
     {    indent2 = pos2 - RtoX[final].Stop1( ) + 1;
          pos2 -= indent2;
          if ( !tig2_rc ) tig2_pos = RtoX[final].Stop2( ) - 1;
          else tig2_pos = RtoX[final].Start2( );    }
     else
     {    indent2 = 0;
          if ( !tig2_rc ) 
               tig2_pos = RtoX[final].Start2( ) + pos2 - RtoX[final].Start1( );
          else 
          {    tig2_pos = RtoX[final].Stop2( ) 
                    - 1 - ( pos2 - RtoX[final].Start1( ) );    }    }


     OK = ( pos1 + indent1 <= pos2 - indent2 );
     return;    }

void genome_coordinate_map::Build( const String& X_agp, const String& R_to_X )
{
     // Track strings by assigning them positive integers.

     map<String, int> string_id;
     vec<String> names;
     names.push_back( "" );

     // Read AGP for X.

     fast_ifstream Xin(X_agp);
     String line, chr, seq_type, part, por;
     int cstart, cstop, index, pstart, pstop;
     
     vec<scaffold_to> trans;

     while(1)
     {    getline( Xin, line );
          if ( Xin.fail( ) ) break;
          if ( line.Contains( "#", 0 ) ) continue;
          istrstream l( line.c_str( ) );
          l >> chr >> cstart >> cstop >> index >> seq_type;
          if ( seq_type == "N" ) continue;
          l >> part >> pstart >> pstop >> por;
          ForceAssertEq( por, "+" );
          --cstart, --pstart;
          int chr_id = string_id[chr];
          if ( chr_id == 0 )
          {    string_id[chr] = names.size( );
               chr_id = names.size( );
               names.push_back(chr);    }
          int part_id = string_id[part];
          if ( part_id == 0 )
          {    string_id[part] = names.size( );
               part_id = names.size( );
               names.push_back(part);    }
          trans.push_back( scaffold_to( chr_id, part_id, ho_interval(cstart, cstop),
               ho_interval(pstart, pstop), (por == "-"), 1 ) );    }

     // Read alignments from R to X;

     fast_pipe_ifstream in( "cat " + R_to_X );
     String chain, id1, id2, or1, or2;
     int len1, len2, start1, start2, stop1, stop2, match, gap1, gap2;
     double score;
     while(1)
     {    getline( in, line );
          if ( in.fail( ) ) break;
          if ( line.size( ) == 0 || line[0] == '#' || isspace( line[0] ) ) continue;
          if ( !line.Contains( "chain", 0 ) ) FatalErr( "chain format invalid" );
          istrstream l( line.c_str( ) );
          l >> chain >> score >> id1 >> len1 >> or1 >> start1 >> stop1 >> id2
               >> len2 >> or2 >> start2 >> stop2;
          ForceAssertEq( or2, "+" );
          int pos1 = start1, pos2 = start2;
          if ( or1 == "-" ) pos1 = len1 - stop1;
          while(1)
          {    getline( in, line );
               if ( in.fail( ) ) FatalErr( "chain format invalid" );
               if ( line.Contains( "#", 0 ) ) continue;
               istrstream m( line.c_str( ) );
               m >> match >> gap1 >> gap2;
               int p1 = ( or1 == "+" ? pos1 : len1 - pos1 - match ), p2 = pos2;
               int id1_id = string_id[id1];
               if ( id1_id == 0 )
               {    string_id[id1] = names.size( );
                    id1_id = names.size( );
                    names.push_back(id1);    }
               int id2_id = string_id[id2];
               if ( id2_id == 0 )
               {    string_id[id2] = names.size( );
                    id2_id = names.size( );
                    names.push_back(id2);    }
               trans.push_back( scaffold_to( id2_id, id1_id, 
                    ho_interval(p2, p2+match), ho_interval(p1, p1+match),
                    (or1 == "-"), 2 ) );
               if ( m.fail( ) ) break;
               pos1 += gap1 + match;
               pos2 += gap2 + match;    }    }

     // Determine aligning segments between R and X contigs.

     Sort(trans);
     for ( int i = 0; i < trans.isize( ); i++ )
     {    const scaffold_to& s1 = trans[i];
          if ( s1.source == 1 ) continue;
          static vec<scaffold_to> c;
          c.clear( );
          for ( int j = i + 1; j < trans.isize( ); j++ )
          {    const scaffold_to& s2 = trans[j];
               if ( s2.scaffold_id != s1.scaffold_id ) break;
               if ( s2.scaffold_range.Start( ) >= s1.scaffold_range.Stop( ) ) break;
               if ( s2.source == 2 ) continue;
               c.push_back(s2);    }
          for ( int j = i - 1; j >= 0; j-- )
          {    const scaffold_to& s2 = trans[j];
               if ( s2.scaffold_id != s1.scaffold_id ) break;
               if ( s2.source == 2 ) continue;
               if ( s2.scaffold_range.Stop( ) <= s1.scaffold_range.Start( ) ) break;
               c.push_back(s2);    }    

          for ( int k = 0; k < c.isize( ); k++ )
          {    const scaffold_to& s2 = c[k];
               ho_interval sint = s1.scaffold_range ^ s2.scaffold_range;
               int start_on_contig = s2.obj_range.Start( )
                    + ( sint.Start( ) - s2.scaffold_range.Start( ) );
               int stop_on_contig = s2.obj_range.Stop( )
                    - ( s2.scaffold_range.Stop( ) - sint.Stop( ) );
               int start_on_chr = s1.obj_range.Start( );
               int stop_on_chr = s1.obj_range.Stop( );
               if ( !s1.rc )
               {    start_on_chr += ( sint.Start( ) - s1.scaffold_range.Start( ) );
                    stop_on_chr -= ( s1.scaffold_range.Stop( ) - sint.Stop( ) );    }
               else
               {    start_on_chr += ( s1.scaffold_range.Stop( ) - sint.Stop( ) );
                    stop_on_chr -= ( sint.Start( ) - s1.scaffold_range.Start( ) );  }

               int tig = names[s2.obj_id].After( "contig_" ).Int( );

               RtoX.push_back( balign( s1.obj_id, tig, 
                    ho_interval(start_on_chr, stop_on_chr),
                    ho_interval(start_on_contig, stop_on_contig), s1.rc ) );    }

          if ( c.size( ) != 1 )
          {    cout << "Warning: " << names[s1.scaffold_id] << "." 
                    << s1.scaffold_range << " <--> " << names[s1.obj_id] << "." 
                    << s1.obj_range << " (" << (s1.rc ? "rc" : "fw") << ")"
                    << " -- " << c.size( ) 
                    << " assembly contigs in aligning region.\n";
               for ( int k = 0; k < c.isize( ); k++ )
               {    const scaffold_to& s2 = c[k];
                    cout << names[s2.scaffold_id] << "." << s2.scaffold_range
                         << " <--> " << names[s2.obj_id] << "." << s2.obj_range 
                         << " (" << (s2.rc ? "rc" : "fw") << ")\n";    }
               cout << "Ignoring alignment.\n\n";
               continue;    }    }    

     // Set up coordinate map.

     Sort(RtoX);
     for ( int i = 0; i < RtoX.isize( ); i++ )
     {    if ( i == 0 || RtoX[i].id1 != RtoX[i-1].id1 ) 
               Rchr.push_back( names[ RtoX[i].id1 ] );    }
     for ( int i = 0; i < RtoX.isize( ); i++ )
          RtoX[i].id1 = BinPosition( Rchr, names[ RtoX[i].id1 ] );

     // Check for overlap.

     if ( !Valid(True) )
     {    cout << "\nValidation check failed.\n";
          exit(1);    }    }
